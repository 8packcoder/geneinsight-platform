import { NextApiRequest, NextApiResponse } from 'next';

// Convert single letter amino acid codes to 3-letter codes for PDB format
function getThreeLetterCode(singleLetter: string): string {
  const aaMap: { [key: string]: string } = {
    'A': 'ALA', 'R': 'ARG', 'N': 'ASN', 'D': 'ASP', 'C': 'CYS',
    'Q': 'GLN', 'E': 'GLU', 'G': 'GLY', 'H': 'HIS', 'I': 'ILE',
    'L': 'LEU', 'K': 'LYS', 'M': 'MET', 'F': 'PHE', 'P': 'PRO',
    'S': 'SER', 'T': 'THR', 'W': 'TRP', 'Y': 'TYR', 'V': 'VAL',
    'X': 'UNK'
  };
  return aaMap[singleLetter] || 'UNK';
}

// Mock protein structure generation
function generateProteinStructure(dnaSequence: string) {
  const cleanSequence = dnaSequence.replace(/\s/g, '').toUpperCase();
  
  // Mock translation to amino acids (simplified)
  const codonTable: { [key: string]: string } = {
    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',
    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',
    'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',
    'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',
    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',
    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',
    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',
    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',
    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',
    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',
    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',
    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',
    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',
    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',
    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'
  };

  let proteinSequence = '';
  for (let i = 0; i < cleanSequence.length - 2; i += 3) {
    const codon = cleanSequence.substring(i, i + 3);
    const aminoAcid = codonTable[codon] || 'X';
    if (aminoAcid === '*') break; // Stop codon
    proteinSequence += aminoAcid;
  }

  // Mock 3D coordinates (simplified alpha helix)
  const atoms = [];
  for (let i = 0; i < Math.min(proteinSequence.length, 50); i++) {
    const angle = (i * 100) * Math.PI / 180; // 100 degrees per residue
    const radius = 2.3; // Alpha helix radius
    const rise = 1.5; // Rise per residue
    
    atoms.push({
      element: 'C',
      x: radius * Math.cos(angle),
      y: radius * Math.sin(angle),
      z: i * rise,
      residue: proteinSequence[i],
      residueNumber: i + 1
    });
  }

  // Generate mock secondary structure
  const secondaryStructure = [];
  for (let i = 0; i < proteinSequence.length; i++) {
    const structures = ['H', 'E', 'C']; // Helix, Sheet, Coil
    secondaryStructure.push(structures[Math.floor(Math.random() * 3)]);
  }

  // Calculate secondary structure percentages
  const helixCount = secondaryStructure.filter(s => s === 'H').length;
  const sheetCount = secondaryStructure.filter(s => s === 'E').length;
  const loopCount = secondaryStructure.filter(s => s === 'C').length;
  const total = secondaryStructure.length;

  const confidence = Math.random() * 0.3 + 0.7;

  return {
    structure3D: {
      success: true,
      structureId: `structure_${Date.now()}`,
      proteinSequence,
      length: proteinSequence.length,
      atoms,
      secondaryStructure: secondaryStructure.join(''),
      confidence: Math.round(confidence * 100) / 100,
      method: 'AI Prediction',
      timestamp: new Date().toISOString(),
      pdbData: generateMockPDB(atoms, proteinSequence),
      secondaryStructure: {
        alphaHelix: total > 0 ? (helixCount / total) * 100 : 0,
        betaSheet: total > 0 ? (sheetCount / total) * 100 : 0,
        loop: total > 0 ? (loopCount / total) * 100 : 0
      },
      molecularProperties: {
        molecularWeight: proteinSequence.length * 110, // Approximate
        isoelectricPoint: 6.5 + Math.random() * 2, // Mock pI
        hydrophobicity: Math.random() * 2 - 1 // Mock hydrophobicity
      }
    }
  };
}

// Generate mock PDB format data with better structure
function generateMockPDB(atoms: any[], sequence: string): string {
  let pdb = 'HEADER    PROTEIN STRUCTURE PREDICTION                        ' + new Date().toISOString().substring(0, 10) + '   PRED\n';
  pdb += 'TITLE     AI-GENERATED PROTEIN STRUCTURE FROM DNA SEQUENCE\n';
  pdb += 'REMARK   1 GENERATED BY GENEINSIGHT PLATFORM\n';
  // Convert sequence to 3-letter codes for SEQRES
  const threeLetterSeq = sequence.split('').map(aa => getThreeLetterCode(aa)).join(' ');
  pdb += `SEQRES   1 A ${sequence.length.toString().padStart(4)}  ${threeLetterSeq}\n`;

  atoms.forEach((atom, index) => {
    // Format atom line according to PDB standard
    const atomNum = (index + 1).toString().padStart(5);
    const atomName = ' CA '; // Carbon Alpha
    const resName = getThreeLetterCode(atom.residue); // Convert to 3-letter code
    const chainId = 'A';
    const resNum = atom.residueNumber.toString().padStart(4);
    const x = atom.x.toFixed(3).padStart(8);
    const y = atom.y.toFixed(3).padStart(8);
    const z = atom.z.toFixed(3).padStart(8);
    const occupancy = '  1.00';
    const tempFactor = ' 20.00';
    const element = '           C';

    const atomLine = `ATOM  ${atomNum}${atomName}${resName} ${chainId}${resNum}    ${x}${y}${z}${occupancy}${tempFactor}${element}\n`;
    pdb += atomLine;
  });

  pdb += 'END\n';
  return pdb;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { sequence } = req.body;

    if (!sequence) {
      return res.status(400).json({ error: 'DNA sequence is required' });
    }

    // Validate DNA sequence
    const dnaPattern = /^[ATCG\s\n\r]+$/i;
    if (!dnaPattern.test(sequence.replace(/\s/g, ''))) {
      return res.status(400).json({ error: 'Invalid DNA sequence' });
    }

    // Generate protein structure
    const structure = generateProteinStructure(sequence);
    
    res.status(200).json(structure);

  } catch (error) {
    res.status(500).json({
      error: 'Structure generation failed',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
